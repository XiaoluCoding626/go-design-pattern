# 外观模式（Facade Pattern）

## 介绍

外观模式是一种结构型设计模式，它为复杂子系统提供一个简化的统一接口，使子系统更易于使用。外观模式定义了一个高层接口，这个接口使得子系统更加容易使用，客户端无需了解系统内部的复杂性。

## 意图

外观模式的主要意图是：
- 为复杂的子系统提供一个简单的接口
- 隔离客户端与子系统的组件
- 将客户端与子系统的耦合度降到最低
- 组织子系统，层次化系统间的依赖关系

## 结构

本实现中的外观模式使用餐厅作为例子，包含以下核心元素：

### 组件结构
1. **多个子系统**：例如供应商、厨师、服务员等，每个子系统执行特定功能
2. **外观类**：`RestaurantFacade`，为客户提供简单统一的接口
3. **客户端**：使用外观类与复杂子系统交互

### UML类图

```
                    ┌───────────────────────┐
                    │   RestaurantFacade    │
                    ├───────────────────────┤
                    │ - vegVendor: VegVendor│
                    │ - meatVendor:MeatVendor
                    │ - warehouse: Warehouse │
                    │ - chef: Chef          │
                    │ - cashier: Cashier    │
                    │ - waiter: Waiter      │
                    │ - cleaner: Cleaner    │
                    ├───────────────────────┤
                    │ + OrderFood()         │
                    │ + PrepareIngredients()│
                    │ + HandlePayment()     │
                    │ + CleanupRestaurant() │
                    │ + CompleteServiceCycle()
                    └───────────────────────┘
                           │
      ┌──────────┬────────┼─────────┬───────────┬─────────┬───────────┐
      │          │        │         │           │         │           │
┌─────▼────┐┌────▼────┐┌──▼───┐┌────▼────┐┌─────▼───┐┌────▼────┐┌─────▼────┐
│VegVendor ││MeatVendor││Chef  ││Warehouse││Cashier  ││ Waiter  ││ Cleaner  │
├──────────┤├──────────┤├──────┤├─────────┤├─────────┤├─────────┤├──────────┤
│+Purchase()││+Purchase()││+Cook()││+Store() ││+Collect ││+TakeOrder│+CleanTable│
│          ││          ││+Prepare││+Retrieve││+Generate││+ServeFood││+CleanFloor│
└──────────┘└──────────┘└──────┘└─────────┘└─────────┘└─────────┘└──────────┘
```

## 实现

本实现使用餐厅服务作为案例，展示外观模式如何协调多个子系统：

1. **子系统组件**
   - `VegVendor` 和 `MeatVendor`：提供食材采购服务
   - `Warehouse`：提供食材存储和管理
   - `Chef`：负责食材准备和烹饪
   - `Waiter`：负责接单和上菜
   - `Cashier`：负责收款和出具收据
   - `Cleaner`：负责餐桌和餐厅清洁

2. **外观接口**
   - `RestaurantFacade`：提供高级服务接口，如：
     - `OrderFood()`：简化点餐流程
     - `HandlePayment()`：简化结账流程
     - `PrepareIngredients()`：简化食材准备流程
     - `CleanupRestaurant()`：简化清理流程
     - `CompleteServiceCycle()`：提供完整的服务周期

## 代码示例

### 创建外观实例

```go
// 创建餐厅外观实例
restaurant := NewRestaurantFacade()
```

### 使用外观提供的简化接口

```go
// 客户只需调用一个方法即可完成点餐
restaurant.OrderFood()

// 管理者可以轻松安排食材准备
restaurant.PrepareIngredients()

// 收银流程被简化为一个调用
restaurant.HandlePayment()

// 清理操作被封装在一个方法中
restaurant.CleanupRestaurant()
```

### 执行完整的服务周期

```go
// 一个方法执行整个服务流程，隐藏所有复杂操作
restaurant.CompleteServiceCycle()
```

## 外观模式输出示例

点餐服务流程:
```
===== 开始点餐服务 =====
服务员接收顾客点单
从仓库取出需要的食材
清洗并准备食材
厨师烹饪美食
服务员将食物送到顾客桌前
===== 点餐服务完成 =====
```

## 优点

1. **隔离性**：客户端与子系统隔离，降低了耦合
2. **简化性**：为客户端提供一个简单的接口，而不必了解系统内部的复杂性
3. **松散耦合**：外观与子系统之间的松散耦合关系有利于系统的分层和维护
4. **安全性**：可以对客户端隐藏不需要暴露的子系统功能，提高安全性

## 缺点

1. **灵活性受限**：对子系统的精细操作被隐藏，失去一定灵活性
2. **违反开闭原则风险**：如果频繁修改外观类，可能违反开闭原则
3. **多层外观可能增加复杂性**：如果创建太多外观层，可能导致系统难以理解

## 应用场景

1. **复杂子系统需要简化接口**：当子系统非常复杂，需要为客户提供简单接口
2. **系统分层**：将系统划分为多个子系统，通过外观降低子系统间依赖
3. **遗留系统封装**：为复杂的遗留系统提供现代化接口
4. **第三方库集成**：提供一个统一的接口来访问多个第三方库的功能

## 与其他模式的关系

- **适配器模式**：适配器改变接口以匹配客户期望，外观简化接口
- **中介者模式**：外观对子系统进行抽象，中介者抽象同事对象之间的交互
- **单例模式**：外观经常实现为单例，因为通常只需要一个外观实例
- **代理模式**：代理控制对对象的访问，外观简化对子系统的访问

## 实际应用

- 用户界面库（如Swing的JApplet）
- Web应用框架中的MVC结构
- 编程语言的标准库包装
- 操作系统的API层
- 企业应用中的服务层