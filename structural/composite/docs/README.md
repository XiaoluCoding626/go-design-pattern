# 组合模式（Composite Pattern）

## 介绍

组合模式是一种结构型设计模式，它允许将对象组合成树形结构来表示"部分-整体"的层次结构，使客户端可以统一处理单个对象和组合对象。

## 意图

组合模式的核心意图是：
- 将对象组合成树形结构以表示"部分-整体"的层次结构
- 让客户端统一处理单个对象和组合对象，无需关心它们的差异
- 构建具有递归性质的对象结构

## 实现原理

本实现采用文件系统作为示例场景，包含以下核心组件：

### 组件结构
1. **Component（组件）**：`Component` 接口定义所有组合对象和叶子对象的公共接口
2. **Leaf（叶子）**：`File` 类表示文件，是叶子节点，不能包含子节点
3. **Composite（组合）**：`Directory` 类表示目录，是组合节点，可以包含子节点
4. **BaseComponent**：提供所有组件共享的基础功能

### 类图
```
+--------------+            +------------------------+
| «interface»  |            |     BaseComponent     |
|  Component   |<-----------| - name: string        |
+--------------+            | - parent: Component   |
| + Name()     |            +------------------------+
| + Path()     |            | + Name()              |
| + Parent()   |            | + Path()              |
| + Add()      |            | + Parent()            |
| + Remove()   |            | + Add()               |
| + GetChild() |            | + Remove()            |
| + IsComposite()|          | + GetChild()          |
| + Size()     |            | + IsComposite()       |
+--------------+            | + Size()              |
                            +------------------------+
                                   ^         ^
                                  /           \
                                 /             \
               +------------------------+ +------------------------+
               |         File          | |      Directory         |
               |---------------------- | |------------------------|
               | - size: int          | | - children: []Component|
               | - content: string    | +------------------------+
               +------------------------+ | + Add()              |
               | + Size()             | | + Remove()            |
               | + Print()            | | + GetChild()          |
               | + IsComposite()      | | + Children()          |
               | + SetContent()       | | + Print()             |
               | + GetContent()       | | + Size()              |
               +------------------------+ | + Find()             |
                                        | | + Count()            |
                                        +------------------------+
```

## 代码示例

### 创建文件和目录

```go
// 创建目录
root := NewDirectory("projects")
docs := NewDirectory("documents")
root.Add(docs)

// 创建文件
report := NewFile("report.pdf", 1024)
docs.Add(report)
```

### 统一处理单个对象和组合对象

```go
// 可以统一处理单个文件或目录
func PrintSize(component Component) {
    fmt.Printf("%s 大小: %d bytes\n", component.Name(), component.Size())
}

// 使用
PrintSize(report) // 处理单个文件
PrintSize(docs)   // 处理整个目录
```

### 递归操作

```go
// 打印整个目录结构
root.Print("")

// 在目录中查找特定文件
results := root.Find("pdf")

// 计算目录大小
totalSize := root.Size()

// 统计文件和目录数量
files, dirs := root.Count()
```

## 优点

1. **简化客户端代码**：客户端可以统一处理简单和复杂对象
2. **方便添加新组件**：符合开闭原则，可以方便地添加新类型的组件
3. **表达层次结构**：自然表达树形结构关系
4. **递归操作便捷**：可以轻松对整个结构执行递归操作

## 应用场景

1. 文件系统：目录包含文件和子目录
2. 图形界面：容器组件包含基本组件和其他容器组件
3. 组织结构：部门包含员工和子部门
4. XML/HTML DOM：元素可以包含文本和其他元素
5. 复合模式：将多个模式组合成一个整体

## 实现注意事项

1. **透明性与安全性平衡**：本实现在透明性和安全性之间取得平衡，子组件方法在基类提供默认实现，并给出错误提示
2. **父引用管理**：维护从子组件到父组件的引用，便于访问整个结构
3. **实现子组件有序性**：通过数组存储子组件，保持添加顺序

## 相关模式

- **装饰器模式**：为组件添加新职责，但不改变接口
- **迭代器模式**：遍历组合结构而不暴露内部实现
- **访问者模式**：在不改变组件类的情况下添加新操作
