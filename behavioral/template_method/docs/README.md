# 模板方法模式（Template Method Pattern）

## 1. 模式介绍

模板方法模式是一种行为型设计模式，它在一个方法中定义一个算法的骨架，而将一些步骤的实现延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

这种模式的核心思想是："好莱坞原则"—— **不要打电话给我们，我们会打电话给你**。即父类调用子类的操作，而不是相反。

## 2. 模式结构

![模板方法模式UML类图](https://refactoringguru.cn/images/patterns/diagrams/template-method/structure-indexed.png)

模板方法模式主要包含以下角色：

1. **抽象类（AbstractClass）**：
   - 定义抽象的原语操作（基本方法）
   - 实现一个模板方法来定义算法骨架

2. **具体类（ConcreteClass）**：
   - 实现抽象类中的原语操作
   - 完成算法中特定步骤的具体实现

## 3. 适用场景

- 当多个类的算法除了一些特定步骤外基本相同时
- 当需要控制子类扩展，只允许在特定点进行扩展时
- 当需要一次性实现一个算法的不变部分，并将可变的行为留给子类实现时
- 当各子类中公共的行为应被提取并集中到一个公共父类中以避免代码重复时

## 4. Go语言实现特点

本实现利用Go语言的特性实现了模板方法模式，具有以下特点：

- 使用接口嵌入代替传统的继承机制
- 通过接口引用实现多态行为
- 在构造函数中正确设置接口引用，确保动态分派到子类方法
- 提供钩子方法让子类控制算法流程

## 5. 代码示例

### 5.1 基本结构

```go
// 抽象类
type AbstractSoyaMilk struct {
    soyaMilkBehavior // 接口嵌入
}

// 子类需要实现的接口
type soyaMilkBehavior interface {
    AddCondiment()                 // 抽象方法
    CustomerWantsCondiments() bool // 钩子方法
    Hook()                         // 额外的钩子方法
}

// 模板方法
func (s *AbstractSoyaMilk) Make() {
    fmt.Println("=== 开始制作豆浆 ===")
    s.SelectBean()
    
    // 使用钩子方法控制流程
    if s.soyaMilkBehavior.CustomerWantsCondiments() {
        s.soyaMilkBehavior.AddCondiment()
    }
    
    s.Soak()
    s.Beat()
    s.soyaMilkBehavior.Hook() 
    fmt.Println("=== 豆浆制作完成 ===")
}
```

### 5.2 具体实现类

```go
// 红豆豆浆
type RedBeanSoyaMilk struct {
    AbstractSoyaMilk
}

func NewRedBeanSoyaMilk() *RedBeanSoyaMilk {
    milk := &RedBeanSoyaMilk{}
    milk.soyaMilkBehavior = milk // 关键：设置接口引用指向自身
    return milk
}

func (r *RedBeanSoyaMilk) AddCondiment() {
    fmt.Println("第 2 步：加入上好的红豆")
}
```

### 5.3 使用钩子方法

```go
// 纯豆浆 - 使用钩子方法跳过添加配料步骤
type PureSoyaMilk struct {
    AbstractSoyaMilk
}

func (p *PureSoyaMilk) CustomerWantsCondiments() bool {
    return false // 控制不添加配料
}
```

## 6. 完整示例 - 豆浆制作

我们以豆浆制作为例展示模板方法模式：

1. **制作流程（模板方法）**：选材 → 添加配料 → 浸泡 → 榨汁
2. **变化点**：不同豆浆在配料上有所不同
3. **钩子方法**：可以控制是否添加配料（制作纯豆浆）

通过模板方法模式，我们可以轻松扩展新的豆浆类型，如红豆豆浆、花生豆浆、纯豆浆等，而无需修改制作流程。

## 7. 优缺点分析

### 优点

1. **代码复用**：将算法的不变部分集中在一个地方，避免重复
2. **扩展性**：允许子类通过重定义特定步骤来扩展算法
3. **反向控制**：体现"好莱坞原则"，父类控制流程，子类填充细节
4. **灵活性**：通过钩子方法提供了额外的扩展点

### 缺点

1. **维护难度**：随着模板方法的增加，维护父类变得复杂
2. **限制性**：子类的行为受限于算法的结构
3. **违反开闭原则风险**：修改父类模板方法可能影响所有子类
4. **难以理解**：算法的整体结构可能分散在不同的类中，降低可读性

## 8. 与其他模式的关系

- **策略模式**：模板方法通过继承来改变算法的部分实现，而策略模式通过组合来改变整个算法
- **工厂方法**：工厂方法可以看作是模板方法模式的一种特殊应用
- **建造者模式**：与模板方法类似，但更关注如何分步创建复杂对象
- **命令模式**：可以结合模板方法，将特定步骤封装为命令对象

## 9. 实现注意事项

在Go语言中实现模板方法模式时，需要注意以下几点：

1. **正确设置接口引用**：确保在构造函数中将接口引用设置为具体实例
2. **接口设计**：接口应包含所有可能被子类覆盖的方法
3. **默认实现**：为钩子方法提供合理的默认实现
4. **文档说明**：清晰注明哪些方法是模板方法，哪些需要子类实现

## 10. 总结

模板方法模式是一种简单而强大的设计模式，特别适用于具有固定流程但部分实现细节可变的场景。它通过将算法骨架与具体步骤实现分离，提高了代码的复用性和扩展性。在Go语言中，尽管没有传统的继承机制，但我们可以通过接口嵌入和组合的方式优雅地实现这一模式。