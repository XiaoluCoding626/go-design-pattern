# 迭代器模式（Iterator Pattern）

## 1. 模式介绍

迭代器模式是一种行为设计模式，它提供了一种方法来访问一个容器对象中的各个元素，而不需要暴露该对象的内部表示。迭代器模式将遍历操作与容器实现分离，使得遍历算法可以独立于容器而变化。

## 2. 模式结构

![迭代器模式UML类图](https://refactoringguru.cn/images/patterns/diagrams/iterator/structure-indexed.png)

迭代器模式主要包含四个角色：

1. **Iterator（迭代器接口）**：定义访问和遍历元素的接口方法。
2. **ConcreteIterator（具体迭代器）**：实现迭代器接口，完成容器元素的遍历。
3. **Aggregate（聚合接口）**：定义创建迭代器的接口。
4. **ConcreteAggregate（具体聚合）**：实现聚合接口，返回一个具体迭代器的实例。

## 3. 适用场景

- 当需要访问一个聚合对象的内容而不暴露其内部表示时
- 当需要提供多种遍历方式时
- 当需要为遍历不同的聚合结构提供一个统一的接口时
- 当需要在不同的层次结构中遍历对象时

## 4. Go语言实现特点

本实现利用Go语言的泛型特性（Go 1.18+）实现了通用的迭代器模式，具有以下特点：

- 使用泛型支持任意数据类型的集合和迭代
- 返回值采用多返回值模式，通过bool指示操作是否成功
- 支持迭代器的重置和获取当前元素功能
- 实现了完整的聚合对象接口，包括添加、删除和获取元素等操作

## 5. 代码示例

### 迭代器接口

```go
type Iterator[T any] interface {
    HasNext() bool      // 是否有下一个元素
    Next() (T, bool)    // 获取下一个元素，返回元素和是否成功
    Reset()             // 重置迭代器
    Current() (T, bool) // 获取当前元素
}
```

### 聚合接口

```go
type Aggregate[T any] interface {
    CreateIterator() Iterator[T] // 创建迭代器
    Add(item T)                  // 添加元素
    Remove(index int) bool       // 移除元素
    Get(index int) (T, bool)     // 获取元素
    Count() int                  // 获取元素数量
}
```

### 使用示例

```go
// 创建字符串集合
strCollection := NewConcreteAggregate[string]()
strCollection.Add("设计模式")
strCollection.Add("迭代器模式")

// 获取迭代器并遍历
iterator := strCollection.CreateIterator()
for iterator.HasNext() {
    item, _ := iterator.Next()
    fmt.Printf("- %s\n", item)
}
```

## 6. 优缺点分析

### 优点

1. **单一职责原则**：将集合的遍历行为分离到迭代器对象中，简化了集合接口
2. **开放封闭原则**：可以实现不同的迭代算法，且不会暴露集合的内部结构
3. **支持并行遍历**：可以同时使用多个迭代器遍历同一个集合
4. **延迟计算**：可以实现按需生成元素的迭代器，适用于大数据集

### 缺点

1. **增加了系统复杂性**：引入了新的接口和类
2. **对于简单集合可能过度设计**：对于结构简单的集合，使用迭代器可能不够直观
3. **在某些语言中效率较低**：与直接访问相比，使用迭代器可能增加一些性能开销

## 7. 与其他模式的关系

- **组合模式**：经常与迭代器模式一起使用，用迭代器遍历复杂的组合结构
- **工厂方法模式**：可用于创建适合特定集合的迭代器
- **备忘录模式**：可与迭代器结合使用，在遍历的同时保存迭代状态

## 8. 总结

迭代器模式是一种简单而强大的设计模式，它将集合的遍历逻辑与集合本身分离，使得客户端代码可以通过统一的接口访问不同类型的集合，而无需关心集合的内部实现细节。在Go语言中，借助泛型特性，我们可以实现更加通用和类型安全的迭代器模式。