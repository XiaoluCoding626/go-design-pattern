# 监视器模式（Monitor Pattern）

## 概述

监视器模式是一种同步设计模式，它将共享数据与同步机制封装在一起，确保对共享资源的并发访问是安全的。监视器通过互斥锁和条件变量的组合，实现了数据保护和线程协作的双重功能。

## 设计意图

监视器模式解决的核心问题是：
- 保护共享资源免受并发访问的影响
- 允许线程在特定条件满足前等待
- 当条件满足时通知等待的线程

## 核心组件

1. **互斥锁**：确保在任意时刻只有一个线程可以访问监视器中的数据
2. **条件变量**：允许线程基于条件等待和接收通知
3. **共享数据**：被监视器保护的数据
4. **同步方法**：封装了对共享数据的安全访问

## 实现原理

监视器工作流程：
1. 进入监视器方法时获取互斥锁
2. 检查访问条件
   - 如果条件不满足，释放锁并等待条件变量信号
   - 条件满足时继续执行
3. 操作共享数据
4. 可能发送信号通知其他等待线程
5. 离开监视器方法前释放互斥锁

## 代码实现

本实现采用Go语言的`sync.Mutex`和`sync.Cond`实现监视器模式：

- `Monitor`结构体封装了互斥锁、条件变量和共享数据
- `Produce`方法允许生产者写入数据并通知等待的消费者
- `Consume`方法允许消费者等待并读取数据
- `Reset`方法重置监视器状态
- `ExecuteProtected`允许在互斥保护下执行自定义操作
- `GetValue`安全地读取当前值

## 使用示例

基本用法：

```go
// 创建监视器
m := NewMonitor()

// 消费者（等待数据）
go func() {
    value := m.Consume() // 阻塞直至数据可用
    fmt.Println("消费到值:", value)
}()

// 生产者（提供数据）
m.Produce(42) // 生产数据并通知消费者
```

## 应用场景

1. **生产者-消费者模型**：多个生产者和消费者需要协作
2. **资源池管理**：控制对有限资源的访问
3. **数据缓冲区**：线程安全的数据缓冲区实现
4. **状态同步**：多线程间的状态协调和通知

## 优势与注意事项

优势：
- 提供高级别的数据封装和线程安全
- 简化并发编程中的同步逻辑
- 可读性好，易于理解和维护

注意事项：
- 需要正确处理条件等待和通知逻辑
- 应避免在持有锁时执行耗时操作
- 注意死锁和活锁风险